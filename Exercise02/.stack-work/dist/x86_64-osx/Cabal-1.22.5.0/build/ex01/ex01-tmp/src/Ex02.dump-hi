
==================== FINAL INTERFACE ====================
2017-12-04 15:05:20.942492 UTC

interface main@main:Ex02 7103
  interface hash: 09924b923511f840e73bb2a6ef70bef3
  ABI hash: 3e4c58923e9a465b95a9f8dca7a821ed
  export-list hash: c4c1c7cc812fc46fbc993ef083d2484b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: cd5ef4d9741abf8c51635c6034f8b7a2
  sig of: Nothing
  used TH splices: False
  where
exports:
  Ex02.getsumsandlength
  Ex02.ins
  Ex02.lkp
  Ex02.twobirdsonestone
  Ex02.IntFun
  Ex02.T{Ex02.A Ex02.B Ex02.C}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Float e532d434ec2447d809887c0fca1d78a5
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
85c6ec66c537d332cfc20f699eaeace7
  $fEqT ::
    (GHC.Classes.Eq k, GHC.Classes.Eq d) => GHC.Classes.Eq (Ex02.T k d)
  DFunId[0]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ k
                      @ d
                      $dEq :: GHC.Classes.Eq k
                      $dEq1 :: GHC.Classes.Eq d.
                  @ (Ex02.T k d)
                  (Ex02.$fEqT_$c== @ k @ d $dEq $dEq1)
                  (Ex02.$fEqT_$c/= @ k @ d $dEq $dEq1) -}
85c6ec66c537d332cfc20f699eaeace7
  $fEqT_$c/= ::
    (GHC.Classes.Eq k, GHC.Classes.Eq d) =>
    Ex02.T k d -> Ex02.T k d -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ k
                   @ d
                   $dEq :: GHC.Classes.Eq k
                   $dEq1 :: GHC.Classes.Eq d
                   a :: Ex02.T k d
                   b :: Ex02.T k d ->
                 case Ex02.$fEqT_$c== @ k @ d $dEq $dEq1 a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
85c6ec66c537d332cfc20f699eaeace7
  $fEqT_$c== ::
    (GHC.Classes.Eq k, GHC.Classes.Eq d) =>
    Ex02.T k d -> Ex02.T k d -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
85c6ec66c537d332cfc20f699eaeace7
  $fShowT ::
    (GHC.Show.Show k, GHC.Show.Show d) => GHC.Show.Show (Ex02.T k d)
  DFunId[0]
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ k
                      @ d
                      $dShow :: GHC.Show.Show k
                      $dShow1 :: GHC.Show.Show d.
                  @ (Ex02.T k d)
                  (Ex02.$fShowT_$cshowsPrec @ k @ d $dShow $dShow1)
                  (Ex02.$fShowT_$cshow @ k @ d $dShow $dShow1)
                  (Ex02.$fShowT_$cshowList @ k @ d $dShow $dShow1) -}
b0d5d59964954dedb5916595ab28aaf5
  $fShowT1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
85c6ec66c537d332cfc20f699eaeace7
  $fShowT_$cshow ::
    (GHC.Show.Show k, GHC.Show.Show d) => Ex02.T k d -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ k
                   @ d
                   $dShow :: GHC.Show.Show k
                   $dShow1 :: GHC.Show.Show d
                   x :: Ex02.T k d ->
                 Ex02.$fShowT_$cshowsPrec
                   @ k
                   @ d
                   $dShow
                   $dShow1
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
85c6ec66c537d332cfc20f699eaeace7
  $fShowT_$cshowList ::
    (GHC.Show.Show k, GHC.Show.Show d) =>
    [Ex02.T k d] -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ k
                   @ d
                   $dShow :: GHC.Show.Show k
                   $dShow1 :: GHC.Show.Show d
                   eta :: [Ex02.T k d]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (Ex02.T k d)
                   (Ex02.$fShowT_$cshowsPrec @ k @ d $dShow $dShow1 Ex02.$fShowT1)
                   eta
                   eta1) -}
85c6ec66c537d332cfc20f699eaeace7
  $fShowT_$cshowsPrec ::
    (GHC.Show.Show k, GHC.Show.Show d) =>
    GHC.Types.Int -> Ex02.T k d -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,1*U(U)><S,1*U> -}
80cfee7f5623cfd9a4d7d0fc146b54b7
  $wgetsumsandlength ::
    GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Int
    -> [GHC.Types.Double]
    -> (# GHC.Types.Double, GHC.Types.Double, GHC.Types.Int #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U)><L,U(U)><L,U(U)><S,1*U>, Inline: [0] -}
6cee3f62aae02fad1d513fb3f971f6a5
  type IntFun = Ex02.T GHC.Types.Int GHC.Types.Int
85c6ec66c537d332cfc20f699eaeace7
  data T k d = A (Ex02.T k d) (Ex02.T k d) k d | B k d | C
    Promotable
b6e21bbd5995cfca9823cd0e3e7f2fe7
  getsumsandlength ::
    GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Int
    -> [GHC.Types.Double]
    -> (GHC.Types.Double, GHC.Types.Double, GHC.Types.Int)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U)><L,U(U)><L,U(U)><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ w :: GHC.Types.Double
                   w1 :: GHC.Types.Double
                   w2 :: GHC.Types.Int
                   w3 :: [GHC.Types.Double] ->
                 case Ex02.$wgetsumsandlength
                        w
                        w1
                        w2
                        w3 of ww { (#,,#) ww1 ww2 ww3 ->
                 (ww1, ww2, ww3) }) -}
4d54a9640f8dc4e4f2ad3c708f3626b6
  ins :: GHC.Classes.Ord k => k -> d -> Ex02.T k d -> Ex02.T k d
  {- Arity: 4,
     Strictness: <L,U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A)><L,U><L,U><S,1*U> -}
8b7ab5c654d59093569a485af04e49d5
  lkp ::
    (GHC.Base.Monad m, GHC.Classes.Ord k) => Ex02.T k d -> k -> m d
  {- Arity: 4,
     Strictness: <S,1*U(A,A,A,1*C1(U),1*C1(U))><L,1*U(1*U(U,U),A,A,A,A,A,A,A)><S,1*U><L,U>,
     Unfolding: (\ @ k
                   @ d
                   @ (m :: * -> *)
                   $dMonad :: GHC.Base.Monad m
                   $dOrd :: GHC.Classes.Ord k
                   eta :: Ex02.T k d
                   eta1 :: k ->
                 case eta of wild {
                   Ex02.A ds ds1 ka da
                   -> case ds of wild1 {
                        DEFAULT -> Ex02.lkp3 @ d @ m
                        Ex02.B k1 d1
                        -> case ds1 of wild2 {
                             DEFAULT -> Ex02.lkp3 @ d @ m
                             Ex02.B k2 d2
                             -> let {
                                  $dEq :: GHC.Classes.Eq k = GHC.Classes.$p1Ord @ k $dOrd
                                } in
                                case GHC.Classes.== @ k $dEq eta1 k1 of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Classes.== @ k $dEq eta1 k2 of wild4 {
                                       GHC.Types.False
                                       -> case GHC.Classes.== @ k $dEq eta1 ka of wild5 {
                                            GHC.Types.False
                                            -> GHC.Base.fail @ m $dMonad @ d Ex02.lkp2
                                            GHC.Types.True -> GHC.Base.return @ m $dMonad @ d da }
                                       GHC.Types.True -> GHC.Base.return @ m $dMonad @ d d2 }
                                  GHC.Types.True -> GHC.Base.return @ m $dMonad @ d d1 } } }
                   Ex02.B k1 d1
                   -> case GHC.Classes.==
                             @ k
                             (GHC.Classes.$p1Ord @ k $dOrd)
                             k1
                             eta1 of wild1 {
                        GHC.Types.False -> GHC.Base.fail @ m $dMonad @ d Ex02.lkp1
                        GHC.Types.True -> GHC.Base.return @ m $dMonad @ d d1 }
                   Ex02.C -> GHC.Base.fail @ m $dMonad @ d Ex02.lkp1 }) -}
808d4be8d5d2e21a306d2964db012563
  lkp1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Error"#) -}
4432f797a5a642829ba7a4b6d031e277
  lkp2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "error"#) -}
8511ecc30f6e766e5426dab860890378
  lkp3 :: m d
  {- Strictness: b -}
55335250c28b0d8bab3a6877caf0ed1b
  twobirdsonestone ::
    GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Int
    -> (GHC.Types.Double, GHC.Types.Double)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U)><L,1*U(U)><L,1*U(U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Double
                   w1 :: GHC.Types.Double
                   w2 :: GHC.Types.Int ->
                 let {
                   nd :: GHC.Types.Double
                   = case w2 of wild { GHC.Types.I# i ->
                     GHC.Types.D# (GHC.Prim.int2Double# i) }
                 } in
                 let {
                   average :: GHC.Types.Double
                   = case w of wild { GHC.Types.D# x ->
                     case nd of wild1 { GHC.Types.D# y ->
                     case GHC.Prim./## x y of wild2 { DEFAULT ->
                     GHC.Types.D# wild2 } } }
                 } in
                 (average,
                  case w1 of wild { GHC.Types.D# x ->
                  case nd of wild1 { GHC.Types.D# y ->
                  case average of wild2 { GHC.Types.D# x1 ->
                  case GHC.Prim./## x y of wild3 { DEFAULT ->
                  GHC.Types.D#
                    (GHC.Prim.sqrtDouble#
                       (GHC.Prim.-## wild3 (GHC.Prim.*## x1 x1))) } } } })) -}
instance GHC.Classes.Eq [Ex02.T] = Ex02.$fEqT
instance GHC.Show.Show [Ex02.T] = Ex02.$fShowT
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

