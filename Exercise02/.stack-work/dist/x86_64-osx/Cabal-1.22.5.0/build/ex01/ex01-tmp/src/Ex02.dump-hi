
==================== FINAL INTERFACE ====================
2017-11-28 14:30:16.890172 UTC

interface main@main:Ex02 7103
  interface hash: c08288a4c3e23823fdf1c3039743240e
  ABI hash: 73be4e039ebaad896cb810c9474bbdc2
  export-list hash: c4c1c7cc812fc46fbc993ef083d2484b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: cd5ef4d9741abf8c51635c6034f8b7a2
  sig of: Nothing
  used TH splices: False
  where
exports:
  Ex02.getsumsandlength
  Ex02.ins
  Ex02.lkp
  Ex02.twobirdsonestone
  Ex02.IntFun
  Ex02.T{Ex02.A Ex02.B Ex02.C}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Float e532d434ec2447d809887c0fca1d78a5
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
85c6ec66c537d332cfc20f699eaeace7
  $fEqT ::
    (GHC.Classes.Eq k, GHC.Classes.Eq d) => GHC.Classes.Eq (Ex02.T k d)
  DFunId[0]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ k
                      @ d
                      $dEq :: GHC.Classes.Eq k
                      $dEq1 :: GHC.Classes.Eq d.
                  @ (Ex02.T k d)
                  (Ex02.$fEqT_$c== @ k @ d $dEq $dEq1)
                  (Ex02.$fEqT_$c/= @ k @ d $dEq $dEq1) -}
85c6ec66c537d332cfc20f699eaeace7
  $fEqT_$c/= ::
    (GHC.Classes.Eq k, GHC.Classes.Eq d) =>
    Ex02.T k d -> Ex02.T k d -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ k
                   @ d
                   $dEq :: GHC.Classes.Eq k
                   $dEq1 :: GHC.Classes.Eq d
                   a :: Ex02.T k d
                   b :: Ex02.T k d ->
                 case Ex02.$fEqT_$c== @ k @ d $dEq $dEq1 a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
85c6ec66c537d332cfc20f699eaeace7
  $fEqT_$c== ::
    (GHC.Classes.Eq k, GHC.Classes.Eq d) =>
    Ex02.T k d -> Ex02.T k d -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
85c6ec66c537d332cfc20f699eaeace7
  $fShowT ::
    (GHC.Show.Show k, GHC.Show.Show d) => GHC.Show.Show (Ex02.T k d)
  DFunId[0]
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ k
                      @ d
                      $dShow :: GHC.Show.Show k
                      $dShow1 :: GHC.Show.Show d.
                  @ (Ex02.T k d)
                  (Ex02.$fShowT_$cshowsPrec @ k @ d $dShow $dShow1)
                  (Ex02.$fShowT_$cshow @ k @ d $dShow $dShow1)
                  (Ex02.$fShowT_$cshowList @ k @ d $dShow $dShow1) -}
b0d5d59964954dedb5916595ab28aaf5
  $fShowT1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
85c6ec66c537d332cfc20f699eaeace7
  $fShowT_$cshow ::
    (GHC.Show.Show k, GHC.Show.Show d) => Ex02.T k d -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ k
                   @ d
                   $dShow :: GHC.Show.Show k
                   $dShow1 :: GHC.Show.Show d
                   x :: Ex02.T k d ->
                 Ex02.$fShowT_$cshowsPrec
                   @ k
                   @ d
                   $dShow
                   $dShow1
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
85c6ec66c537d332cfc20f699eaeace7
  $fShowT_$cshowList ::
    (GHC.Show.Show k, GHC.Show.Show d) =>
    [Ex02.T k d] -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ k
                   @ d
                   $dShow :: GHC.Show.Show k
                   $dShow1 :: GHC.Show.Show d
                   eta :: [Ex02.T k d]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (Ex02.T k d)
                   (Ex02.$fShowT_$cshowsPrec @ k @ d $dShow $dShow1 Ex02.$fShowT1)
                   eta
                   eta1) -}
85c6ec66c537d332cfc20f699eaeace7
  $fShowT_$cshowsPrec ::
    (GHC.Show.Show k, GHC.Show.Show d) =>
    GHC.Types.Int -> Ex02.T k d -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,1*U(U)><S,1*U> -}
80cfee7f5623cfd9a4d7d0fc146b54b7
  $wgetsumsandlength ::
    GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Int
    -> [GHC.Types.Double]
    -> (# GHC.Types.Double, GHC.Types.Double, GHC.Types.Int #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U)><L,U(U)><L,U(U)><S,1*U>, Inline: [0] -}
6cee3f62aae02fad1d513fb3f971f6a5
  type IntFun = Ex02.T GHC.Types.Int GHC.Types.Int
85c6ec66c537d332cfc20f699eaeace7
  data T k d = A (Ex02.T k d) (Ex02.T k d) k d | B k d | C
    Promotable
b6e21bbd5995cfca9823cd0e3e7f2fe7
  getsumsandlength ::
    GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Int
    -> [GHC.Types.Double]
    -> (GHC.Types.Double, GHC.Types.Double, GHC.Types.Int)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(U)><L,U(U)><L,U(U)><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ w :: GHC.Types.Double
                   w1 :: GHC.Types.Double
                   w2 :: GHC.Types.Int
                   w3 :: [GHC.Types.Double] ->
                 case Ex02.$wgetsumsandlength
                        w
                        w1
                        w2
                        w3 of ww { (#,,#) ww1 ww2 ww3 ->
                 (ww1, ww2, ww3) }) -}
4d54a9640f8dc4e4f2ad3c708f3626b6
  ins :: GHC.Classes.Ord k => k -> d -> Ex02.T k d -> Ex02.T k d
  {- Arity: 4,
     Strictness: <L,U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A)><L,U><L,U><S,1*U> -}
57e5d90f07070fb6b543c8469607ff9a
  lkp ::
    (GHC.Base.Monad m, GHC.Classes.Ord k) => Ex02.T k d -> k -> m d
  {- Arity: 4, Strictness: <B,A><B,A><B,A><B,A>b,
     Unfolding: InlineRule (4, True, True)
                (\ @ k
                   @ d
                   @ (m :: * -> *)
                   $dMonad :: GHC.Base.Monad m
                   $dOrd :: GHC.Classes.Ord k
                   ds :: Ex02.T k d
                   ds1 :: k ->
                 Ex02.lkp1 @ d @ m) -}
1ee58b811d048caba55fa692ae74740c
  lkp1 :: m d
  {- Strictness: b -}
55335250c28b0d8bab3a6877caf0ed1b
  twobirdsonestone ::
    GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Int
    -> (GHC.Types.Double, GHC.Types.Double)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U)><L,1*U(U)><L,1*U(U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Double
                   w1 :: GHC.Types.Double
                   w2 :: GHC.Types.Int ->
                 let {
                   nd :: GHC.Types.Double
                   = case w2 of wild { GHC.Types.I# i ->
                     GHC.Types.D# (GHC.Prim.int2Double# i) }
                 } in
                 let {
                   average :: GHC.Types.Double
                   = case w of wild { GHC.Types.D# x ->
                     case nd of wild1 { GHC.Types.D# y ->
                     case GHC.Prim./## x y of wild2 { DEFAULT ->
                     GHC.Types.D# wild2 } } }
                 } in
                 (average,
                  case w1 of wild { GHC.Types.D# x ->
                  case nd of wild1 { GHC.Types.D# y ->
                  case average of wild2 { GHC.Types.D# x1 ->
                  case GHC.Prim./## x y of wild3 { DEFAULT ->
                  GHC.Types.D#
                    (GHC.Prim.sqrtDouble#
                       (GHC.Prim.-## wild3 (GHC.Prim.*## x1 x1))) } } } })) -}
instance GHC.Classes.Eq [Ex02.T] = Ex02.$fEqT
instance GHC.Show.Show [Ex02.T] = Ex02.$fShowT
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

